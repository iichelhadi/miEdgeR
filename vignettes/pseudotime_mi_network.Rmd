---
title: "Pseudotime-Aware MI Network Analysis with miEdgeR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Pseudotime-Aware MI Network Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, dev = "png", dev.args = list(type = "cairo"))
```

## About this vignette

This tutorial demonstrates how to incorporate pseudotime information into mutual-information (MI) network analysis using miEdgeR. We bin cells along a trajectory, build MI networks per bin, detect communities, and track dynamic changes in modules, hub genes, and enrichment across pseudotime.

## Prerequisites:

R (≥ 4.2.0)

Seurat object containing cluster metadata and a numeric pseudotime column

Packages: miEdgeR, Seurat, igraph, clusterProfiler, org.Hs.eg.db, ggplot2, ggraph, flextable, pheatmap

## Introduction

Single-cell trajectories often represent continuous biological change, but many network methods produce a single “static” gene network. This vignette shows how to make MI-network analysis pseudotime-resolved using miEdgeR.

We start from a vignette-ready Seurat object containing an epithelial lineage subset (basal → club → secretory) and a Slingshot-derived pseudotime (pseudotime1). We then:

1. bin cells along pseudotime,

2. infer an MI network within each bin, and

3. compare inferred networks across bins to quantify changes in gene–gene dependencies, communities, hub genes, and edge gain/loss.

    Note: This dataset and pseudotime are used to demonstrate the workflow mechanics. Parameter choices (binning, thresholds, gene counts) are tuned for a fast, reproducible vignette rather than definitive biological inference.

## Load Libraries and Data

Load all dependencies and read the preprocessed Seurat object. Ensure your object includes clustering and pseudotime metadata.

```{r}
library(Seurat)
library(miEdgeR)
library(igraph)
library(clusterProfiler)
library(org.Hs.eg.db)
library(dplyr)
library(ggplot2)
library(ggraph)
library(flextable)
library(pheatmap)

set.seed(123)

seurat_obj <- readRDS('organoid_epithelial_lineage_pseudotime.rds')

seurat_obj@assays$RNA <- seurat_obj@assays$originalexp
DefaultAssay(seurat_obj) <- "RNA"
seurat_obj@assays$originalexp <- NULL

```

## Pseudotime distribution

```{r,fig.alt="pseudotime distribution histogram"}

p_pt <- ggplot(seurat_obj@meta.data, aes(x = pseudotime1)) +
  geom_histogram(bins = 40, color = "black") +
  labs(
    title = "Pseudotime distribution (epithelial lineage subset)",
    x = "pseudotime1",
    y = "Cell count"
  ) +
  theme_minimal()

print(p_pt)
```

## UMAP colored by pseudotime

```{r, fig.width = 7, fig.height = 7, fig.alt="umap of cell types and pseudotime"}
stopifnot("umap" %in% names(seurat_obj@reductions))

um <- as.data.frame(Embeddings(seurat_obj, "umap"))
um$cell <- rownames(um)
um$pseudotime1 <- seurat_obj$pseudotime1[um$cell]
um$cell_type <- seurat_obj$cell_type[um$cell]

p_um1 <- ggplot(um, aes(x = UMAP_1, y = UMAP_2, color = cell_type)) +
  geom_point(size = 0.25, alpha = 0.7) +
  labs(title = "UMAP colored by pseudotime1") +
  theme_minimal()

p_um2 <- ggplot(um, aes(x = UMAP_1, y = UMAP_2, color = pseudotime1)) +
  geom_point(size = 0.25, alpha = 0.7) +
  labs(title = "UMAP colored by pseudotime1") +
  theme_minimal()

p_um1/p_um2

```

## Prepare a single “lineage” label for miEdgeR

`compute_pseudotime_mi_network()` expects a `cluster_field` + `cluster_id` to select cells.
Because this vignette object is already subset to the epithelial lineage, we create a single label (lineage_demo) so the function can select all cells consistently.

```{r}
seurat_obj$lineage_demo <- "epithelial_lineage_demo"
```

## Compute pseudotime-resolved MI networks

For each pseudotime bin (n_bins = 3), we:

-select lineage cells,
-filter genes by expression prevalence,
-keep the top variable genes,
-compute MI,
-threshold to build a graph per bin.

```{r}
pt_results <- miEdgeR::compute_pseudotime_mi_network(
  seurat_obj     = seurat_obj,
  cluster_id     = "epithelial_lineage_demo",
  cluster_field  = "lineage_demo",
  pseudotime_col = "pseudotime1",
  assay_name     = "RNA",
  counts_layer   = "counts",
  data_layer     = "data",
  min_expr_pct   = 0.05,
  top_n_genes    = 2000,   # reduce for vignette runtime
  min_cells_bin  = 50,
  n_bins         = 3,
  n_cores        = max(1, parallel::detectCores() - 3)
)

cat("Valid bins:", sum(!sapply(pt_results, is.null)), "\n")
names(pt_results)

```

## Summarize Bin Graphs

Quick summary of node and edge counts and density per bin to assess network complexity over pseudotime.

```{r}
for (bin in names(pt_results)) {
  if (!is.null(pt_results[[bin]])) {
    cat("Bin", bin, "- Vertices:", igraph::vcount(pt_results[[bin]]), "\n")
    cat("Bin", bin, "- Edges:", igraph::ecount(pt_results[[bin]]), "\n")
    cat("Bin", bin, "- Density:", igraph::graph.density(pt_results[[bin]]), "\n\n")
  } else {
    cat("Bin", bin, "- Skipped (insufficient cells)\n\n")
  }
}

```

## Community detection across pseudotime bins

We detect robust communities per bin using percolation (consensus filtering) followed by Leiden clustering and overlap expansion.

```{r}
comm_results <- detect_communities_across_bins(
  pt_results,
  min_size = 50,
  n_iterations = 100,
  edge_fraction = 0.6,
  freq_threshold = 0.5,
  percentile = 0.95,
  resolution_parameter = 0.5,
  overlap_threshold = 0.1
)
```

We applied `detect_communities_across_bins()` to identify stable gene communities across pseudotime bins. Each bin’s consensus MI network revealed large co-expression modules, with Bins PT1 and PT3 showing two major communities, while Bin PT2 displayed one community. This indicates changes in MI-supported gene–gene associations across pseudotime bins in MG.

## Community sizes across bins

Bar plot showing how module sizes vary across pseudotime bins.

```{r, fig.width = 7, fig.alt="bar plot of module sizes per bin"}
comm_sizes_df <- bind_rows(lapply(comm_results, function(res) {
  data.frame(
    Bin = res$bin,
    Community = paste("Group", seq_along(res$sizes)),
    Size = res$sizes
  )
}))

p_comm_sizes <- ggplot(comm_sizes_df, aes(x = Bin, y = Size, fill = Community)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Community sizes across pseudotime bins (epithelial lineage demo)",
    x = "Pseudotime bin",
    y = "Community size"
  ) +
  theme_minimal()

print(p_comm_sizes)

```

## Edge Gain/Loss Analysis

Compare stable, gained, and lost edges between consecutive pseudotime bins.

```{r, fig.width=8, fig.alt="bar plot of edges changes between bins"}
result <- plot_edge_gain_loss(pt_results, cluster_id = "epithelial_lineage_demo")
print(result$plot)

export_edge_changes <- function(edge_details, transition, write_csv = FALSE) {
  ed <- edge_details[[transition]]
  if (is.null(ed)) {
    message(transition, ": no edge data available")
    return(invisible(NULL))
  }

  out <- list()

  for (type in c("gained", "lost", "stable")) {
    edges <- ed[[type]]

    if (!is.data.frame(edges) || nrow(edges) == 0) {
      message(sprintf("%s – %s edges: none", transition, type))
      next
    }

    message(sprintf("%s – %s edges (showing first 10):", transition, type))
    print(utils::head(edges, 10))

    if (isTRUE(write_csv)) {
      utils::write.csv(
        edges,
        file = sprintf("%s_edges_%s.csv", type, gsub(" ", "_", transition)),
        row.names = FALSE
      )
    }

    out[[type]] <- edges
  }

  invisible(out)
}

# Inspect transitions
export_edge_changes(result$edge_details, "PT1 to PT2", write_csv = FALSE)
export_edge_changes(result$edge_details, "PT2 to PT3", write_csv = FALSE)

```

To further explore dynamic gene interactions, we used `plot_edge_gain_loss()` to quantify and visualize stable, gained, and lost edges between consecutive pseudotime bins. The function returns both a summary plot and detailed edge lists for each transition. For example, from **PT1→PT2**, over 120K edges were gained or lost, and ~70K remained stable. Exported edge tables (e.g., 'gained_edges_PT1_to_PT2.csv') can be used for downstream analysis of context-specific co-regulation.

## Gene-Pseudotime Correlation Density

Plot distribution of gene expression–pseudotime correlations to gauge overall trends.

```{r, fig.width=8, fig.alt="Distriution of gene correlations with pseudotime"}
gc_df <- gene_pt_correlation(
  seurat_obj,
  pseudotime_col = "pseudotime1",
  assay = "RNA",
  layer = "data",
  method = "spearman"
)

p_gc <- ggplot(gc_df, aes(x = Cor)) +
  geom_density(alpha = 0.35) +
  labs(
    title = "Gene–pseudotime correlation density (Spearman)",
    x = "Spearman rho",
    y = "Density"
  ) +
  theme_minimal()

print(p_gc)

```

## Top ±10 Genes by Correlation

Plot top 10 positively and negatively correlated genes.

```{r, fig.width = 6, fig.height=6, fig.alt="Bar plot of genes correlated with pseudotime" }
top_genes_df <- gc_df %>%
  filter(!is.na(Cor)) %>%
  slice_max(Cor, n = 10) %>%
  mutate(Direction = "Positive") %>%
  bind_rows(
    gc_df %>% filter(!is.na(Cor)) %>% slice_min(Cor, n = 10) %>% mutate(Direction = "Negative")
  ) %>%
  mutate(Gene = factor(Gene, levels = unique(Gene)))

p_top_genes <- ggplot(top_genes_df, aes(x = Cor, y = Gene, fill = Direction)) +
  geom_col(show.legend = FALSE) +
  facet_grid(Direction ~ ., scales = "free_y") +
  labs(
    title = "Top ±10 genes by pseudotime correlation",
    x = "Spearman rho",
    y = ""
  ) +
  theme_minimal()

print(p_top_genes)

```

## Heatmap of top 10 positively correlated genes

Heatmap of top 10 genes by pseudotime correlation.

```{r, fig.width= 8, fig.alt="Heatmap of top 10 genes correlated with pseudotime"}
top10 <- gc_df %>% filter(!is.na(Cor)) %>% slice_max(Cor, n = 10) %>% pull(Gene) %>% unique()

valid_cells <- colnames(seurat_obj)[!is.na(seurat_obj$pseudotime1)]
cells <- valid_cells[order(seurat_obj$pseudotime1[valid_cells])]

expr <- GetAssayData(seurat_obj, assay = "RNA", slot = "data")
present <- intersect(top10, rownames(expr))

mat <- expr[present, cells, drop = FALSE]
pheatmap(
  mat,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_colnames = FALSE,
  main = "Top 10 positively correlated genes (ordered by pseudotime)"
)

```

## Module-Score Trajectories (MI-derived modules)

Module scores are computed using genes from MI-derived communities in PT1. This ensures module trajectories are fully consistent with the inferred network structure.

```{r, fig.width=8, fig.alt="Module trajectory plot"}
# Identify PT1 index explicitly
pt1_idx <- which(sapply(comm_results, `[[`, "bin") == "PT1")
stopifnot(length(pt1_idx) == 1)

pt1_res <- comm_results[[pt1_idx]]

mods <- lapply(pt1_res$communities, head, 50)
names(mods) <- paste0("Community_", seq_along(mods))

p_modtraj <- plot_module_trajectories(
  comm_results,
  seurat_obj,
  bin_index = pt1_idx,
  custom_modules = mods,
  pseudotime_field = 'pseudotime1',
  cluster_field = "lineage_demo",
  cluster_id = "epithelial_lineage_demo",
  assay = "RNA"
)

print(p_modtraj)

```

## GO enrichment for PT1 – Community 1

GO enrichment of the largest PT1 MI community highlights coherent biological processes, illustrating how miEdgeR-derived modules can be functionally interpreted at specific pseudotime stages.

```{r, fig.width=10, fig.alt="GSEA enrichment"}
## GO enrichment for a representative MI community (PT1, Community 1)

## ===============================
## Hallmark enrichment of PT1 MI communities
## ===============================

suppressPackageStartupMessages({
  library(fgsea)
  library(msigdbr)
  library(org.Hs.eg.db)
})

hallmark <- msigdbr(species = "Homo sapiens") %>%
  filter(gs_cat == "H") %>%
  split(x = .$gene_symbol, f = .$gs_name)

ensembl_to_symbol_stats <- function(stats_ens) {
  ens_ids <- names(stats_ens)

  map <- AnnotationDbi::select(
    org.Hs.eg.db,
    keys     = ens_ids,
    keytype  = "ENSEMBL",
    columns  = "SYMBOL"
  )

  map <- map[!is.na(map$SYMBOL), c("ENSEMBL", "SYMBOL")]
  sym <- map$SYMBOL[match(ens_ids, map$ENSEMBL)]

  keep <- !is.na(sym)
  stats <- stats_ens[keep]
  names(stats) <- sym[keep]

  # collapse duplicate symbols deterministically
  stats <- tapply(stats, names(stats), max)
  stats <- sort(as.numeric(stats), decreasing = TRUE)
  names(stats) <- names(tapply(stats_ens[keep], sym[keep], max))

  stats
}

run_fgsea_safe <- function(stats, pathways, nperm = 5000) {
  overlap <- sum(names(stats) %in% unique(unlist(pathways)))
  message("Stats genes: ", length(stats), " | Overlap with pathway universe: ", overlap)

  if (overlap < 50) {
    message("Low overlap; enrichment may be uninformative for this demo.")
  }

  fg <- fgsea(
    pathways    = pathways,
    stats       = stats,
    nPermSimple = nperm
  )

  fg <- fg[order(fg$pval), ]
  fg
}

plot_fgsea_top <- function(fg, title, n = 15) {
  top <- fg %>% slice_head(n = n)
  ggplot(top, aes(x = NES, y = reorder(pathway, NES))) +
    geom_col() +
    labs(title = title, y = NULL) +
    theme_minimal()
}

g_pt1 <- pt1_res$consensus_graph
stopifnot("weight" %in% edge_attr_names(g_pt1))

cluster_gene_weights_ens <- lapply(pt1_res$communities, function(genes) {
  genes <- intersect(genes, V(g_pt1)$name)
  subg <- induced_subgraph(g_pt1, vids = genes)
  w <- strength(subg, weights = E(subg)$weight)
  w <- w - mean(w)            # optional; you can remove if it flattens too much
  sort(w, decreasing = TRUE)
})

stats_c1 <- ensembl_to_symbol_stats(cluster_gene_weights_ens[[1]])
fg_c1 <- run_fgsea_safe(stats_c1, hallmark, nperm = 10000)

print(nrow(fg_c1))
print(head(fg_c1, 10))
print(plot_fgsea_top(fg_c1, "PT1 – Community 1 Hallmark enrichment (top nominal sets)"))


```

## Save Results

```{r}
# saveRDS(pt_results, "pseudotime_results.rds")
# saveRDS(comm_results, "pseudotime_communities.rds")

```

```{r}
sessionInfo()
```
